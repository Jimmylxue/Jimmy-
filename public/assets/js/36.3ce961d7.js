(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{519:function(s,a,n){"use strict";n.r(a);var t=n(4),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"前端性能优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[s._v("#")]),s._v(" 前端性能优化")]),s._v(" "),n("p",[s._v("对于前端来说，性能优化无非就是执行相隔方面，分别是。文件获取优化和代码执行优化")]),s._v(" "),n("h2",{attrs:{id:"节流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[s._v("#")]),s._v(" 节流")]),s._v(" "),n("blockquote",[n("p",[s._v("某一段时间只触发一次")])]),s._v(" "),n("p",[s._v("典型例子就是图片懒加载")]),s._v(" "),n("h2",{attrs:{id:"防抖-debounce"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#防抖-debounce"}},[s._v("#")]),s._v(" 防抖 -- debounce")]),s._v(" "),n("blockquote",[n("p",[s._v("输入完成之后再统一的发 sing 请求，最后的一个任说了算，只能最后一次")])]),s._v(" "),n("p",[s._v("典型例子就是用户输入")]),s._v(" "),n("h3",{attrs:{id:"节流和防抖总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#节流和防抖总结"}},[s._v("#")]),s._v(" 节流和防抖总结")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("节流")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('  <!DOCTYPE html>\n    <html lang="en">\n      <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n        <style>\n          div {\n            width: 500px;\n            height: 5000px;\n            background-color: skyblue;\n          }\n        </style>\n      </head>\n      <body>\n        <div></div>\n        <script>\n          /*\n            浏览器滚动是触发非常灵敏的一个事件，这个也是前端必须要会的一个优化\n              有时候我们只是轻轻的滚动一下  但是事件就能触发个几十甚至上百次\n          */\n          let i = 0\n          let lasttime = 0\n          window.addEventListener(\'scroll\', () => {\n            let now = new Date().getTime()\n            if (now - lasttime > 200) {\n              i++\n              console.log(i)\n              lasttime = now\n            }\n          })\n          /*\n            使用了节流之后  只要滚动条之后 就会强制  指定的时间内再执行事件\n          */\n        <\/script>\n      </body>\n    </html>\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("防抖")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('  <!DOCTYPE html>\n    <html lang="en">\n      <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>防抖</title>\n        <style>\n          div {\n            width: 500px;\n            height: 5000px;\n            background-color: skyblue;\n          }\n        </style>\n      </head>\n      <body>\n        <div></div>\n        <script>\n          let timer\n          window.addEventListener(\'scroll\', () => {\n            clearTimeout(timer)\n            timer = setTimeout(() => {\n              console.log(\'start\')\n            }, 1000)\n          })\n          // 只有在最后一次滚动的时候才会执行 这个就叫做防抖\n        <\/script>\n      </body>\n    </html>\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])])])]),s._v(" "),n("ul",[n("li",[s._v("节流是会稳定的持续性的输出，防抖是只有最后一次会输出")])]),s._v(" "),n("h2",{attrs:{id:"回流重绘"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#回流重绘"}},[s._v("#")]),s._v(" 回流重绘")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、搞或隐藏元素等）时，浏览器就要重新计算几何属性（其他元素的几几何位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就叫做回流（也叫重排）")])]),s._v(" "),n("li",[n("p",[s._v("重绘：当我们对 DOM 的修改导致了样式的变化，却并未影响其几何属性（比如修改了颜色和背景色）时，乱来娶你不需要计算元素的几何属性，直接为该元素绘制新的样式（跳过了回流换届）。这个过程就叫做重绘")])]),s._v(" "),n("li",[n("p",[s._v("重绘不一定导致回流，回流一定导致重绘")])])]),s._v(" "),n("h2",{attrs:{id:"虚拟-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[s._v("#")]),s._v(" 虚拟 dom")]),s._v(" "),n("blockquote",[n("p",[s._v("由于 DOM 的属性实在是太多太多了，如果直接在浏览器里面操作 DOM 是十分消耗资源的事情，所以就用 JS 代码片段来表示一个 DOM，这样就节约了很多的资源")])]),s._v(" "),n("h2",{attrs:{id:"vue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[s._v("#")]),s._v(" Vue")]),s._v(" "),n("p",[s._v("其实我们只用做好异步组件，Vue 本身已经足够快了，但是还是有一个可以优化的点")]),s._v(" "),n("h3",{attrs:{id:"v-if-vs-v-show"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v-if-vs-v-show"}},[s._v("#")]),s._v(" v-if vs v-show")]),s._v(" "),n("p",[s._v("初始性能 vs 频繁切换性能")]),s._v(" "),n("h3",{attrs:{id:"和渲染无关的数据，不要放在-data-上"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#和渲染无关的数据，不要放在-data-上"}},[s._v("#")]),s._v(" 和渲染无关的数据，不要放在 data 上")]),s._v(" "),n("p",[s._v("data 也不要嵌套过多层")]),s._v(" "),n("ul",[n("li",[s._v("放在 data 中的数据就都是会通过"),n("code",[s._v("Object.definePrototpy")]),s._v("重新渲染一遍数据，一些没必要响应式的数据就没必要放在 data 里面，直接放在 this 之上就可以了")])]),s._v(" "),n("h3",{attrs:{id:"nexttick"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[s._v("#")]),s._v(" nextTick")]),s._v(" "),n("p",[s._v("修改数据的当下，试图不会立刻更新，而是等同一时间循环中的所有数据都变化完成之后，再会做同一的视图更新")]),s._v(" "),n("h3",{attrs:{id:"object-freeze"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#object-freeze"}},[s._v("#")]),s._v(" Object.freeze()")]),s._v(" "),n("p",[s._v("冻结数据，取消 setters")])])}),[],!1,null,null,null);a.default=e.exports}}]);