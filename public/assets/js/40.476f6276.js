(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{520:function(s,a,n){"use strict";n.r(a);var t=n(4),r=Object(t.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"数据结构算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构算法"}},[s._v("#")]),s._v(" 数据结构算法")]),s._v(" "),n("p",[s._v("数据格式 算法是脱离语言的")]),s._v(" "),n("p",[s._v("算法复杂度")]),s._v(" "),n("blockquote",[n("p",[s._v("简单理解就是一个算法有多快，比如经常会有大神会说，你这代码性能不行。实际上就差不多是说复杂度不行，效率不高")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/2020082116061142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI0MDE2Mg==,size_16,color_FFFFFF,t_70#pic_center",alt:"算法复杂度对比图"}})]),s._v(" "),n("p",[s._v("各种算法都有最好情况的时候和最坏情况的时候，所以一般拿来评判一个算法的好坏，平均时间复杂度是比较好的一个标准")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("给一个数组 arr 和数字 sum，如何在数字里，找到两个数字 a，b 使得 a+b==sum")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("算法 1")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  // 两层循环  复杂度属于  O*n^2 一层循环要执行n次 两层循环n平方次  （O可以理解成一个量级）\n  // 属于暴力破解的方式\n\n  let arr = [13,1,2,5,3,8,11]\n  let sum = 18\n\n  function findSum(arr,sum){\n    for(let i = 0;i < arr.length;i++){\n      for(let j = 0;j < arr.length;j++){\n        if(i!=j && arr[i]+arr[j] == sum){\n          console.log(i,j,arr[i],arr[j])\n        }\n      }\n    }\n  }\n\n  findSum(arr,sum)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br")])]),n("p",[s._v("O*n^2 的时间复杂度其实相对来说是不太容易被接受的，可以简单的理解如果一个数组有长度是 7，那么就会执行 7^2 49 次，那如果一个数组长度是一万，那么这个执行结果就会执行一亿次")])]),s._v(" "),n("li",[n("p",[s._v("算法 2")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v(" //值用了一层循环 所以时间复杂度是 O*N\n // O*N 和 O*N^2 差别就非常大了，如果一个数组有一万个元素，那么两者时间复杂度就相差一万倍\n  let arr = [13,1,2,5,3,8,11]\n  let sum = 18\n\n  let obj = {}\n\n  arr.forEach((item,index)=>{\n    if(String(item) in obj){\n      console.log('找到了')\n      console.log(obj[item],index)\n    }\n    obj[sum-item] = index\n  })\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])])])])])]),s._v(" "),n("h3",{attrs:{id:"数组"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[s._v("#")]),s._v(" 数组")]),s._v(" "),n("p",[s._v("数组常见复杂度")]),s._v(" "),n("ul",[n("li",[s._v("搜索复杂度")]),s._v(" "),n("li",[s._v("删除复杂度")]),s._v(" "),n("li",[s._v("新增复杂度")])]),s._v(" "),n("p",[s._v("内存中的存储数据，其实是有点像数组的链表，以及要理解对象是怎么存的。")]),s._v(" "),n("p",[s._v("数组的优缺点")]),s._v(" "),n("ol",[n("li",[s._v("有序 （根据索引查找） 复杂度是 O*1 (常量级)")]),s._v(" "),n("li",[s._v("搜索复杂度：O*N, 如果业务的搜索量很大 就考虑不用数组")]),s._v(" "),n("li",[s._v("新增复杂度 在 x 位置插一个元素，x 之后的位置都向后一个位置，然后才可以插入，所以新增的复杂度也是 O*N")]),s._v(" "),n("li",[s._v("删除复杂度： 后面的元素要填满前面的元素，所以复杂度也是 O*N")])]),s._v(" "),n("h4",{attrs:{id:"数组排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组排序"}},[s._v("#")]),s._v(" 数组排序")]),s._v(" "),n("ul",[n("li",[n("p",[s._v("冒泡排序")]),s._v(" "),n("p",[s._v("冒泡排序是有两层 for 循环，所以时间复杂度是 O*N^2"),n("br"),s._v("\n两两比较，如果和预期不一样就这两个交换一下位置")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  let arr = [3, 44, 13, 1, 8, 9, 7, 1, 2]\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] > arr[j]) {\n        let temp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = temp\n      }\n    }\n  }\n  console.log(arr)  // [1, 1,  2,  3, 7,8, 9, 13, 44    ]\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])]),s._v(" "),n("li",[n("p",[s._v("快速选择排序"),n("br"),s._v("\n快速排序 复杂度是 O"),n("em",[s._v("lgN,我们可以理解 O")]),s._v("n 的复杂度增长非常非常快 那么 O*lgN 复杂度增长的就非常非常的慢"),n("br"),s._v("\n缺点： 空间占用的多 占用了很多的变量")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  let arr1 = [3, 44, 13, 1, 8, 9, 7, 1, 2]\n\n  function quickSort(arr) {\n    if (arr.length < 1) {\n      return arr\n    }\n    let flag = arr[0]\n    let left = []\n    let right = []\n    for (let i = 1; i < arr.length; i++) {\n      if (arr[i] < flag) {\n        left.push(arr[i])\n      } else {\n        right.push(arr[i])\n      }\n    }\n\n    return [...quickSort(left), flag, ...quickSort(right)]\n  }\n\n  console.log(quickSort(arr1))\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])])])]),s._v(" "),n("h3",{attrs:{id:"链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[s._v("#")]),s._v(" 链表")]),s._v(" "),n("blockquote",[n("p",[s._v("例如一链表 1=》2=》3=》4")])]),s._v(" "),n("ul",[n("li",[s._v("搜索复杂度")]),s._v(" "),n("li",[s._v("删除复杂度"),n("br"),s._v("\n删除 2 需要要 1=》3 （1 直接指向 3 即可）")]),s._v(" "),n("li",[s._v("新增复杂度\n2=》5; 5=》3 即可")])]),s._v(" "),n("p",[s._v("总结：链表的新增和删除和链表本身的长度是没关系的，所以新增和删除的复杂度都是 O1")]),s._v(" "),n("h3",{attrs:{id:"hash-表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hash-表"}},[s._v("#")]),s._v(" hash 表")]),s._v(" "),n("blockquote",[n("p",[s._v("JS 的 Object 数据类型，就是 hashTable 的一种实现")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("  class hashTable {\n    constructor() {\n      this.table = []\n    }\n    // 获取唯一的key值转换的数值， 真正的操作肯定不会这么的简单的 但是原理就是这么一个原理\n    calcuteHash(key) {\n      let hash = 0\n      for (let s of key) {\n        hash+=s.charCodeAt()\n      }\n      return hash%10\n    }\n    get(key) {\n      let hash = this.calcuteHash(key)\n      return this.table[hash]\n    }\n    put(key, value) {\n      let index = this.calcuteHash(key)\n      this.table[index] = value\n    }\n  }\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br")])]),n("p",[s._v("一旦发生了碰撞（两个哈希的 key 一致）那么就只能扩容或者存储链表来处理了。"),n("br"),s._v("\n特点：查找元素是复杂度是 O1(查找贼快) 新增和删除也都是 O1（贼快）\n一旦发生碰撞，就需要扩容，会导致数据的雪崩效应")]),s._v(" "),n("h3",{attrs:{id:"栈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[s._v("#")]),s._v(" 栈")]),s._v(" "),n("p",[s._v("栈是一种遵循先进后出原则的有序集合"),n("br"),s._v("\n方法调用，作用域")]),s._v(" "),n("h3",{attrs:{id:"队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[s._v("#")]),s._v(" 队列")]),s._v(" "),n("p",[s._v("队列是一种遵循先进先出原则的有序集合")]),s._v(" "),n("h3",{attrs:{id:"树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[s._v("#")]),s._v(" 树")]),s._v(" "),n("blockquote",[n("p",[s._v("前端接触比较多的数据结构其实就是树了，因为我们前端浏览器一些 DOM 树 CSS 树之类的都是使用数这么一个类型结构，虽然并不是一个完美的二叉树，但是就是一个树")])]),s._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200821160143157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjI0MDE2Mg==,size_16,color_FFFFFF,t_70#pic_center",alt:"树的基本结构"}})]),s._v(" "),n("h3",{attrs:{id:"图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[s._v("#")]),s._v(" 图")]),s._v(" "),n("p",[s._v("闭合的树")])])}),[],!1,null,null,null);a.default=r.exports}}]);