---
title: 第二周（2021-11-07）
date: 2021-11-07
sidebar: 'auto'
categories:
  - 周记说前端
tags:
  - 日常
---

## 2021-11-07

### 关于这个每周笔记专栏

写博客是个很简单的事情,同时写博客也是个很难的事情,我并没有指望能够像B站那些技术大牛的博客能有千上万的读者来观看,甚至实现了内容变现,我写这个的目的是希望能够处理我的拖延症.

说实话我是一个拖延症很重的患者,生活中是编程和学习方面也是这样,我会预期规划好要这周要做的事情,但是到了以后总想着下次吧,不急,等等一系列的接口,导致自己的计划永远不能很完美的实现,就像今天的这篇文章的内容.看似简单,实则并不是那么的简单.

这个专栏的内容我是规定自己每周至少更新一篇,但我估计也只会是一篇,一直坚持更新下去,这个很不容易,但是应该比我健身容易,在能每日完成一个小时健身量的我看来,这个新任务我也能完成.

专栏博客里面的内容会是技术和生活杂糅在一起的方式,可能会让观者看的非常的不适,前者还在说自己的所看所想,后者直接180度大转弯进入技术分享阶段.

是的,我知道这样并不好,但是我太懒了,不能指望着一下子改变,所以目前是以这个形式写下去,如果有人提意见,我会非常开心的接收并着手去改的!

### 会说话的人真的很讨喜

我很内向,在很多时候我不敢开口讲话,这个性格真的很不好,我甚至有时候对我自己的女朋友都不能很好的直接抒发自己内容的感觉,会选择不说,我也意识到这个是个非常不好的性格,是一定得改的.大学时我就有逼着自己主动多做一些事,多讲一些话,在大学好像这个效果好了一些,但是现在在公司一个新环境,有时候又会变成那个不是很敢说话的自己.

这周公司有进行团建,我和另外一个新加入的公司的前端小伙伴几乎都在一起活动,我发现他比我想象中的融入集体更快,快到令我有感到羡慕,很快就和伙伴们打成一片,虽然我也融入进去,但是这个小伙伴的融入速度令我震惊,这个"软技能"是现在我除了程序技术需要修炼之外,另外一个非常重要且急需修炼的一套内功!

### 关于读书

自从我开始写博客开始,我发现我开始慢慢试着做一件之前最不喜欢的事情 ---- 看书.

书本都是精华,每一本书可能是作者一两年甚至是好几十年的心血,但却能被我们通过一个月甚至更短的时间全部吸收转换成自己的东西,这太棒了,现在的我已经买了七八本书了,其中收获最大的莫过于前端的《javascript高级程序设计》第四版,这本书令我对`js`这门语言有了更加深入的理解,正如我的领导小姐姐的一句话:"现在会用框架开发的人太多了,但是真正懂JS,会原理方面的知识的人市场的需求量还是很大的."

确实当初读书有过一段很疯狂的时候,早上八点起床读书,直到九点上班,还有晚上健身结束之后的任务也是读书,在书中充斥着大量的笔记,当我准备二次阅读的时候,我将这本书带到了公司,公司的前端同事都表示震惊(因为这本书真的是非常的厚!),我居然读完了,而且书中有这很多的笔记,这是我感觉到最自信的时候.

很遗憾中途松懈了一段时间,现在我会重新开始,每天至少半小时的技术书,还是其他方面(修身养性)的书也会读,因为我确实太需要提升一下自己的人际交往方面的软技能了.

### Node

是的没有错,现在进入技术讨论区域了

> 在过去我一直以为Node就是一个能做后端的活的一个工具,只能做后端服务器方面的开发,但是随着自己工作年限的增长以及接触的前端的东西越来越多,我发现这个想法实际上是非常错误的,而且大多会出现在小白的心中
>
> 虽然我现在学习的知识目前好像对我的前端职业发展没有什么实际性的提升,但是真正对node学的比较好的前端程序员应该还是比较少的.这个也会是我的优势之一.

本周我阅读《Node.js硬实战》讲的是一些特殊的Node的使用技巧,一下是学习中一些收获的点,之后也会陆续的将新学习到的内容更新到这个项目文件下[node系统学习](https://gitee.com/jimmyxuexue/node-system-learning.git)

#### 流

回想一些我对流的比较有印象的场景发生在一年前,那时候我在做自己的毕业设计的图片上传模块时,我就正常的使用`axios.post()`传图片时,发现传递的参数变成了一个以前从未见过的东西,之后百度才发现,这个就是流!!!

目前知道的是流是数据的集合,这一点和数组对象都一样都是用来存储数据的,区别就在于流可能并不是一次性就获取到,所以它就不需要匹配内存空间,基于这个特性流可以非常适用于处理大容量数据的处理. 

分为了四类,分别是:

- 可读流 - http response(clinet)  process.stdin
- 可写流 - http request(server)  process.stdout
- 双向流 - scoket
- 转换流

在看书的时候对流处理数据其实还是一知半解,真正让我对流处理数据的理解更进一步的是在知乎专栏上的一篇文章[Node.js 流（stream）：你需要知道的一切](https://zhuanlan.zhihu.com/p/36728655)里面有一个访问400M文件的例子非常的给力.另外我在gitee上记载了几个也非常不错的流的例子[Node - 流学习笔记](https://gitee.com/jimmyxuexue/node-system-learning.git)

个别例子:

```js


const { Readable } = require("stream");

const inStream = new Readable({});

/**
 * 这里有一个实现可读流简单的方式。我们可以直接 push 消费者想要消费的数据。
 */
inStream.push("Hello world");
inStream.push("Jimmy");
inStream.push("xuexue");
inStream.push("Jack");
inStream.push(null); // 当我们 push 一个 null 对象，意味着我们想要标识流没有更多的数据了。

/**
 * 为了消费这个简单的可读的流，我们可以简单地将它导入到可写流 process.stdout。
 */
inStream.pipe(process.stdout);
/**
 * 最终控制台会输出 Hello worldJimmyxuexueJack
 */
```

总结:

- 流一定是共同存在才有意义，且能互相消费
- 我们需要消费可读流时  需要使用可写流进行消费可读流
- 我们需要消费可写流时  需要使用可读流进行消费可写流

#### process

在过去使用`KOA`写服务端时代码提示工具经常会看到`process`这个关键字,看名字知道这个可能跟进程有关系,实则这个时Node一个非常重要的一个环境变量,基于它可以用来于操作系统进行通信.

[学习笔记](https://gitee.com/jimmyxuexue/node-system-learning.git)

在过去,我一直不知道使用node怎么创建类型于C语言的在控制台输出一段话,后面你再输入内容,会根据你输入的内容做出相应的处理.其实这个就是一个简单的系统通信,但是过去我就是无法实现,会出现这个原因时因为自己没有系统的学习,而是一开始就想着去学习服务器的内容,这些基础Node的环境变量都没有学习,这个实际上是需要使用`process`来实现的.

以下这个例子就是基于流和process实现的一个简单的系统通信

```js
/**
 * 这里就简单的创建了一个 可写的流
 */
const { Writable } = require("stream");

/**
 * outStream是 Writable 这个可写流的实例 所以outStream是一个可写流
 */
const outStream = new Writable({
  /**
   *
   * @param chunk  chunk 通常是一个 buffer
   * @param encoding  encoding 在那种情况下时需要的，但是通常我们可以忽略它
   * @param callback  是一个当我们处理完数据块之后需要调用的一个函数。它标识着是否写入成功，为了标识失败，可以调用一个带有错误对象的 callback。
   */
  write(chunk, encoding, callback) {
    /**
     * 在控制台输入什么 就是立即打印出 出入的结果
     *  这个就是使用流的效果
     */
    console.log("chunk！", chunk.toString());
    callback();
  },
});

/**
 * 为了消费这个 可写流 我们就需要一个 可读流来消费它
 *    process.stdin 是一个node的一个最基础的一个可读流
 */
process.stdin.pipe(outStream);
/**
 * pipe 方法是消费流最简单的方法,通常建议使用 pipe 方法或者事件来消费流
 */

```

`process`的一些API

- `process.stdout` 最简单方法创建可写流

- `process.stdin` 最简单方法创建可读流

- `process.argv` 获取命令函的传入的脚本参数

  如执行 `node argument.js -r argument.js` 这时候可以像数组的方式使用`process.argv`如`process.argv[1]`可以分别的获取到参数 如 -r 、 argument.js 等等

- `process.exit(1)`退出程序并传递退出码,如这里的退出码是1,默认除了退出码是0其他的都代表异常退出

### 结束语

希望各位观众老爷能进入[Jimmy的个人空间](http://1.116.204.114:3000/)支持一下.